def fetch_all_movies(session):
    """Fetch all movies with their details."""
    query = """
    MATCH (m:Movie)
    RETURN m.title AS title, m.released AS released, m.tagline AS tagline
    """
    result = session.run(query)
    movies = [
        {
            "title": record["title"],
            "released": record["released"],
            "tagline": record["tagline"]
        }
        for record in result
    ]
    return {"message": f"Fetched {len(movies)} movies.", "data": movies}


def fetch_movie_details(session, movie_title):
    """Fetch details of a specific movie."""
    query = f"""
    MATCH (m:Movie {{title: '{movie_title}'}})<-[r]-(p:Person)
    RETURN m.title AS title, m.released AS released, m.tagline AS tagline,
           collect({{name: p.name, born: p.born, relationship: type(r), roles: r.roles}}) AS people
    """
    result = session.run(query)
    record = result.single()
    if not record:
        return {"message": f"No details found for movie '{movie_title}'."}
    movie_details = {
        "title": record["title"],
        "released": record["released"],
        "tagline": record["tagline"],
        "people": record["people"]
    }
    return {"message": f"Details for movie '{movie_title}' fetched successfully.", "data": movie_details}


def fetch_people_in_movies(session, person_name):
    """Fetch movies associated with a specific person."""
    query = f"""
    MATCH (p:Person {{name: '{person_name}'}})-[r]->(m:Movie)
    RETURN p.name AS name, p.born AS born,
           collect({{title: m.title, released: m.released, relationship: type(r), roles: r.roles}}) AS movies
    """
    result = session.run(query)
    record = result.single()
    if not record:
        return {"message": f"No movies found for person '{person_name}'."}
    person_details = {
        "name": record["name"],
        "born": record["born"],
        "movies": record["movies"]
    }
    return {"message": f"Movies for person '{person_name}' fetched successfully.", "data": person_details}


@app.get("/process_input")
async def process_input(
    type: str = Query(...), startNode: str = None, endNode: str = None, inputValue: str = None
):
    """Processes input data sent from the frontend."""
    print(f"Received type: {type}, startNode: {startNode}, endNode: {endNode}, inputValue: {inputValue}")
    try:
        with driver.session() as session:
            if type == "Fetch All Movies":
                return fetch_all_movies(session)
            elif type == "Fetch Movie Details" and inputValue:
                return fetch_movie_details(session, inputValue)
            elif type == "Fetch People in Movies" and inputValue:
                return fetch_people_in_movies(session, inputValue)
            elif type == "Find Shortest Distance" and startNode and endNode:
                return find_shortest_distance(session, startNode, endNode)
            elif type == "Find no of Nodes":
                return find_no_of_nodes(session)
            elif type == "Find Nodes connected from a node" and inputValue:
                return find_connected_nodes_from(session, inputValue)
            elif type == "Find Nodes connected to a node" and inputValue:
                return find_connected_nodes_to(session, inputValue)
            elif type == "Common Neighbors" and startNode and endNode:
                return find_common_neighbors(session, startNode, endNode)
            elif type == "All Shortest Paths" and startNode and endNode:
                return find_all_shortest_paths(session, startNode, endNode)
            else:
                return {"message": f"Invalid input or type: {type}"}

    except Exception as e:
        print("Error processing input:", e)
        return {"message": f"Error: {str(e)}"}